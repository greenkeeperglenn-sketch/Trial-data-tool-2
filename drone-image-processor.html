<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drone Image Processor - Turf Trial Grid Detector</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/opencv.js@1.2.1/opencv.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        .content {
            padding: 30px;
        }
        .upload-section {
            border: 3px dashed #4CAF50;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            background: #f8fdf8;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .upload-section:hover {
            border-color: #45a049;
            background: #f0faf0;
        }
        .upload-section.drag-over {
            border-color: #2196F3;
            background: #e3f2fd;
        }
        .upload-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .upload-btn:hover {
            background: #45a049;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .control-group {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
        }
        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }
        .control-group input[type="number"],
        .control-group input[type="range"],
        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 1em;
        }
        .value-display {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        .advanced-toggle {
            text-align: center;
            margin-bottom: 20px;
        }
        .advanced-toggle button {
            background: #f5f5f5;
            border: 2px solid #ddd;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }
        .advanced-toggle button:hover {
            background: #e0e0e0;
        }
        .advanced-controls {
            display: none;
            margin-bottom: 20px;
        }
        .advanced-controls.visible {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        .grid-preview {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: #fafafa;
            margin-bottom: 20px;
        }
        .grid-preview h3 {
            margin-bottom: 10px;
            color: #333;
        }
        .canvas-wrapper {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }
        canvas {
            max-width: 100%;
            border-radius: 4px;
            background: #fff;
            display: block;
        }
        #gridCanvas {
            cursor: crosshair;
        }
        .plots-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .plot-item {
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }
        .plot-item:hover {
            border-color: #4CAF50;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .plot-item img {
            width: 100%;
            height: auto;
            display: block;
        }
        .plot-label {
            padding: 10px;
            background: #f5f5f5;
            color: #333;
        }
        .plot-number {
            font-weight: 600;
            font-size: 1.1em;
            margin-bottom: 4px;
        }
        .plot-coverage {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95em;
        }
        .coverage-bar {
            flex: 1;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }
        .coverage-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s ease;
        }
        .coverage-text {
            font-weight: 600;
            color: #4CAF50;
        }
        .stats {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .stats h3 {
            color: #1976D2;
            margin-bottom: 15px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #bbdefb;
        }
        .stat-item:last-child {
            border-bottom: none;
        }
        .btn-secondary {
            background: #2196F3;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            margin-right: 10px;
            transition: background 0.3s ease;
        }
        .btn-secondary:hover {
            background: #1976D2;
        }
        .btn-success {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            margin-right: 10px;
            transition: background 0.3s ease;
        }
        .btn-success:hover {
            background: #45a049;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.2em;
        }
        .info-box {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .info-box h4 {
            color: #856404;
            margin-bottom: 8px;
        }
        .info-box p {
            color: #856404;
            margin: 5px 0;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            align-items: center;
            justify-content: center;
        }
        .modal.active {
            display: flex;
        }
        .modal-content {
            max-width: 90%;
            max-height: 90%;
            position: relative;
        }
        .modal-content img {
            max-width: 100%;
            max-height: 90vh;
            border-radius: 8px;
        }
        .modal-close {
            position: absolute;
            top: -40px;
            right: 0;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
        }
        .modal-info {
            position: absolute;
            bottom: -120px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
        }
        .modal-label {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .modal-coverage {
            font-size: 20px;
            color: #8BC34A;
        }
        .modal-metadata {
            font-size: 14px;
            color: #ccc;
            margin-top: 10px;
        }
        .metadata-section {
            background: #e8f5e9;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .metadata-section h3 {
            color: #2e7d32;
            margin-bottom: 15px;
        }
        .metadata-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        .metadata-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #4CAF50;
        }
        .metadata-label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
            margin-bottom: 4px;
        }
        .metadata-value {
            color: #333;
            font-size: 1.1em;
        }
        .image-queue {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .image-queue h3 {
            margin-bottom: 15px;
            color: #333;
        }
        .queue-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 2px solid #ddd;
        }
        .queue-item.processing {
            border-color: #2196F3;
            background: #e3f2fd;
        }
        .queue-item.completed {
            border-color: #4CAF50;
            background: #e8f5e9;
        }
        .queue-info {
            flex: 1;
        }
        .queue-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
        }
        .status-pending {
            background: #fff3cd;
            color: #856404;
        }
        .status-processing {
            background: #2196F3;
            color: white;
        }
        .status-completed {
            background: #4CAF50;
            color: white;
        }
        .plot-metadata {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        function TurfTrialDetector() {
            const [imageQueue, setImageQueue] = useState([]);
            const [currentImageIndex, setCurrentImageIndex] = useState(null);
            const [image, setImage] = useState(null);
            const [originalImage, setOriginalImage] = useState(null);
            const [imageMetadata, setImageMetadata] = useState(null);
            const [isProcessing, setIsProcessing] = useState(false);
            const [corners, setCorners] = useState([]);
            const [gridCorners, setGridCorners] = useState([]);
            const [draggingCorner, setDraggingCorner] = useState(null);
            const [rows, setRows] = useState(0);
            const [cols, setCols] = useState(0);
            const [minArea, setMinArea] = useState(50);
            const [maxArea, setMaxArea] = useState(5000);
            const [markerColor, setMarkerColor] = useState('bright');
            const [greenSensitivity, setGreenSensitivity] = useState(35);
            const [showAdvanced, setShowAdvanced] = useState(false);
            const [isDragging, setIsDragging] = useState(false);
            const [opencvReady, setOpencvReady] = useState(false);
            const [committed, setCommitted] = useState(false);
            const [allPlots, setAllPlots] = useState([]);
            const [selectedPlot, setSelectedPlot] = useState(null);

            const gridCanvasRef = useRef(null);
            const fileInputRef = useRef(null);

            useEffect(() => {
                const checkOpenCV = setInterval(() => {
                    if (window.cv && window.cv.Mat) {
                        setOpencvReady(true);
                        clearInterval(checkOpenCV);
                    }
                }, 100);

                return () => clearInterval(checkOpenCV);
            }, []);

            useEffect(() => {
                if (originalImage && image && opencvReady && currentImageIndex !== null) {
                    const timer = setTimeout(() => {
                        processImage(originalImage);
                    }, 200);
                    return () => clearTimeout(timer);
                }
            }, [originalImage, image, opencvReady, minArea, maxArea, markerColor]);

            useEffect(() => {
                if (gridCorners.length === 4 && rows > 0 && cols > 0 && originalImage && !committed) {
                    drawGrid();
                }
            }, [gridCorners, rows, cols, committed]);

            const extractEXIF = (file) => {
                return new Promise((resolve) => {
                    EXIF.getData(file, function() {
                        const exif = EXIF.getAllTags(this);
                        const metadata = {
                            fileName: file.name,
                            fileSize: (file.size / 1024 / 1024).toFixed(2) + ' MB',
                            dateTime: exif.DateTime || 'N/A',
                            make: exif.Make || 'N/A',
                            model: exif.Model || 'N/A',
                            latitude: null,
                            longitude: null,
                            altitude: exif.GPSAltitude ? exif.GPSAltitude + 'm' : 'N/A',
                            imageWidth: exif.PixelXDimension || 'N/A',
                            imageHeight: exif.PixelYDimension || 'N/A',
                            orientation: exif.Orientation || 'N/A',
                            focalLength: exif.FocalLength ? exif.FocalLength + 'mm' : 'N/A',
                            iso: exif.ISOSpeedRatings || 'N/A',
                            exposureTime: exif.ExposureTime || 'N/A',
                            fNumber: exif.FNumber || 'N/A'
                        };

                        // Convert GPS coordinates
                        if (exif.GPSLatitude && exif.GPSLongitude) {
                            metadata.latitude = convertDMSToDD(
                                exif.GPSLatitude[0],
                                exif.GPSLatitude[1],
                                exif.GPSLatitude[2],
                                exif.GPSLatitudeRef
                            );
                            metadata.longitude = convertDMSToDD(
                                exif.GPSLongitude[0],
                                exif.GPSLongitude[1],
                                exif.GPSLongitude[2],
                                exif.GPSLongitudeRef
                            );
                        }

                        resolve(metadata);
                    });
                });
            };

            const convertDMSToDD = (degrees, minutes, seconds, direction) => {
                let dd = degrees + minutes / 60 + seconds / 3600;
                if (direction === 'S' || direction === 'W') {
                    dd = dd * -1;
                }
                return dd.toFixed(6);
            };

            const handleFilesUpload = async (files) => {
                const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));

                if (imageFiles.length === 0) return;

                const newQueue = [];
                for (let i = 0; i < imageFiles.length; i++) {
                    const file = imageFiles[i];
                    const metadata = await extractEXIF(file);

                    newQueue.push({
                        id: Date.now() + i,
                        file,
                        metadata,
                        status: 'pending',
                        plots: []
                    });
                }

                setImageQueue(prev => [...prev, ...newQueue]);

                // Auto-start processing first image if none is being processed
                if (currentImageIndex === null && newQueue.length > 0) {
                    loadImageFromQueue(0);
                }
            };

            const loadImageFromQueue = (index) => {
                if (index >= imageQueue.length) return;

                const queueItem = imageQueue[index];
                const file = queueItem.file;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        setOriginalImage(img);
                        setImage(e.target.result);
                        setImageMetadata(queueItem.metadata);
                        setCurrentImageIndex(index);
                        setGridCorners([]);
                        setCorners([]);
                        setCommitted(false);

                        // Update queue status
                        setImageQueue(prev => prev.map((item, idx) =>
                            idx === index ? { ...item, status: 'processing' } : item
                        ));
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                setIsDragging(false);
                handleFilesUpload(e.dataTransfer.files);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                setIsDragging(true);
            };

            const handleDragLeave = () => {
                setIsDragging(false);
            };

            const calculateGreenCoverage = (imgData) => {
                const data = imgData.data;
                let totalPixels = 0;
                let greenPixels = 0;

                const hueMin = 35 - greenSensitivity;
                const hueMax = 85 + greenSensitivity;
                const satMin = 20;
                const valMin = 20;

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    const delta = max - min;

                    let h = 0;
                    const s = max === 0 ? 0 : (delta / max) * 100;
                    const v = (max / 255) * 100;

                    if (delta !== 0) {
                        if (max === r) {
                            h = 60 * (((g - b) / delta) % 6);
                        } else if (max === g) {
                            h = 60 * (((b - r) / delta) + 2);
                        } else {
                            h = 60 * (((r - g) / delta) + 4);
                        }
                    }

                    if (h < 0) h += 360;

                    if (h >= hueMin && h <= hueMax && s >= satMin && v >= valMin) {
                        greenPixels++;
                    }

                    totalPixels++;
                }

                return (greenPixels / totalPixels) * 100;
            };

            const detectGridDimensions = (detectedCorners) => {
                if (detectedCorners.length < 4) {
                    return { rows: 0, cols: 0 };
                }

                const sortedByY = [...detectedCorners].sort((a, b) => a.y - b.y);
                const rowTolerance = 50;
                const rowGroups = [];
                let currentRow = [sortedByY[0]];

                for (let i = 1; i < sortedByY.length; i++) {
                    if (Math.abs(sortedByY[i].y - currentRow[0].y) < rowTolerance) {
                        currentRow.push(sortedByY[i]);
                    } else {
                        rowGroups.push(currentRow);
                        currentRow = [sortedByY[i]];
                    }
                }
                rowGroups.push(currentRow);

                const sortedByX = [...detectedCorners].sort((a, b) => a.x - b.x);
                const colTolerance = 50;
                const colGroups = [];
                let currentCol = [sortedByX[0]];

                for (let i = 1; i < sortedByX.length; i++) {
                    if (Math.abs(sortedByX[i].x - currentCol[0].x) < colTolerance) {
                        currentCol.push(sortedByX[i]);
                    } else {
                        colGroups.push(currentCol);
                        currentCol = [sortedByX[i]];
                    }
                }
                colGroups.push(currentCol);

                const detectedRows = rowGroups.length - 1;
                const detectedCols = colGroups.length - 1;

                return {
                    rows: Math.max(1, detectedRows),
                    cols: Math.max(1, detectedCols)
                };
            };

            const initializeGridCorners = (detectedCorners) => {
                if (detectedCorners.length < 4) return;

                const allX = detectedCorners.map(c => c.x);
                const allY = detectedCorners.map(c => c.y);

                const minX = Math.min(...allX);
                const maxX = Math.max(...allX);
                const minY = Math.min(...allY);
                const maxY = Math.max(...allY);

                const topLeft = detectedCorners.reduce((closest, corner) => {
                    const dist = Math.sqrt(Math.pow(corner.x - minX, 2) + Math.pow(corner.y - minY, 2));
                    const closestDist = Math.sqrt(Math.pow(closest.x - minX, 2) + Math.pow(closest.y - minY, 2));
                    return dist < closestDist ? corner : closest;
                });

                const topRight = detectedCorners.reduce((closest, corner) => {
                    const dist = Math.sqrt(Math.pow(corner.x - maxX, 2) + Math.pow(corner.y - minY, 2));
                    const closestDist = Math.sqrt(Math.pow(closest.x - maxX, 2) + Math.pow(closest.y - minY, 2));
                    return dist < closestDist ? corner : closest;
                });

                const bottomLeft = detectedCorners.reduce((closest, corner) => {
                    const dist = Math.sqrt(Math.pow(corner.x - minX, 2) + Math.pow(corner.y - maxY, 2));
                    const closestDist = Math.sqrt(Math.pow(closest.x - minX, 2) + Math.pow(closest.y - maxY, 2));
                    return dist < closestDist ? corner : closest;
                });

                const bottomRight = detectedCorners.reduce((closest, corner) => {
                    const dist = Math.sqrt(Math.pow(corner.x - maxX, 2) + Math.pow(corner.y - maxY, 2));
                    const closestDist = Math.sqrt(Math.pow(closest.x - maxX, 2) + Math.pow(closest.y - maxY, 2));
                    return dist < closestDist ? corner : closest;
                });

                setGridCorners([
                    { ...topLeft, label: 'TL' },
                    { ...topRight, label: 'TR' },
                    { ...bottomRight, label: 'BR' },
                    { ...bottomLeft, label: 'BL' }
                ]);
            };

            const getMousePos = (canvas, evt) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (evt.clientX - rect.left) * scaleX,
                    y: (evt.clientY - rect.top) * scaleY
                };
            };

            const handleMouseDown = (e) => {
                if (committed) return;

                const canvas = gridCanvasRef.current;
                if (!canvas) return;

                const pos = getMousePos(canvas, e);
                const hitRadius = 30;

                for (let i = 0; i < gridCorners.length; i++) {
                    const corner = gridCorners[i];
                    const dist = Math.sqrt(
                        Math.pow(pos.x - corner.x, 2) +
                        Math.pow(pos.y - corner.y, 2)
                    );

                    if (dist < hitRadius) {
                        setDraggingCorner(i);
                        break;
                    }
                }
            };

            const handleMouseMove = (e) => {
                if (draggingCorner === null || committed) return;

                const canvas = gridCanvasRef.current;
                if (!canvas) return;

                const pos = getMousePos(canvas, e);

                const newCorners = [...gridCorners];
                newCorners[draggingCorner] = {
                    ...newCorners[draggingCorner],
                    x: pos.x,
                    y: pos.y
                };
                setGridCorners(newCorners);
            };

            const handleMouseUp = () => {
                setDraggingCorner(null);
            };

            const drawGrid = () => {
                const canvas = gridCanvasRef.current;
                if (!canvas || !originalImage || gridCorners.length !== 4) return;

                const ctx = canvas.getContext('2d');
                canvas.width = originalImage.width;
                canvas.height = originalImage.height;

                ctx.drawImage(originalImage, 0, 0);

                const [topLeft, topRight, bottomRight, bottomLeft] = gridCorners;

                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = 4;

                for (let i = 0; i <= rows; i++) {
                    const t = i / rows;
                    const leftPoint = {
                        x: topLeft.x + (bottomLeft.x - topLeft.x) * t,
                        y: topLeft.y + (bottomLeft.y - topLeft.y) * t
                    };
                    const rightPoint = {
                        x: topRight.x + (bottomRight.x - topRight.x) * t,
                        y: topRight.y + (bottomRight.y - topRight.y) * t
                    };

                    ctx.beginPath();
                    ctx.moveTo(leftPoint.x, leftPoint.y);
                    ctx.lineTo(rightPoint.x, rightPoint.y);
                    ctx.stroke();
                }

                for (let i = 0; i <= cols; i++) {
                    const t = i / cols;
                    const topPoint = {
                        x: topLeft.x + (topRight.x - topLeft.x) * t,
                        y: topLeft.y + (topRight.y - topLeft.y) * t
                    };
                    const bottomPoint = {
                        x: bottomLeft.x + (bottomRight.x - bottomLeft.x) * t,
                        y: bottomLeft.y + (bottomRight.y - bottomLeft.y) * t
                    };

                    ctx.beginPath();
                    ctx.moveTo(topPoint.x, topPoint.y);
                    ctx.lineTo(bottomPoint.x, bottomPoint.y);
                    ctx.stroke();
                }

                gridCorners.forEach((corner, i) => {
                    ctx.fillStyle = i === draggingCorner ? '#FFA500' : '#FF0000';
                    ctx.beginPath();
                    ctx.arc(corner.x, corner.y, 25, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(corner.x, corner.y, 18, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.fillStyle = i === draggingCorner ? '#FFA500' : '#FF0000';
                    ctx.beginPath();
                    ctx.arc(corner.x, corner.y, 12, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(corner.label, corner.x, corner.y);
                });

                ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
                corners.forEach((corner) => {
                    ctx.beginPath();
                    ctx.arc(corner.x, corner.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                });
            };

            const commitGrid = () => {
                if (gridCorners.length !== 4 || !originalImage || currentImageIndex === null) return;

                setIsProcessing(true);

                setTimeout(() => {
                    try {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = originalImage.width;
                        tempCanvas.height = originalImage.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(originalImage, 0, 0);

                        let src = cv.imread(tempCanvas);

                        const [topLeft, topRight, bottomRight, bottomLeft] = gridCorners;

                        const width = Math.max(
                            Math.sqrt(Math.pow(topRight.x - topLeft.x, 2) + Math.pow(topRight.y - topLeft.y, 2)),
                            Math.sqrt(Math.pow(bottomRight.x - bottomLeft.x, 2) + Math.pow(bottomRight.y - bottomLeft.y, 2))
                        );
                        const height = Math.max(
                            Math.sqrt(Math.pow(bottomLeft.x - topLeft.x, 2) + Math.pow(bottomLeft.y - topLeft.y, 2)),
                            Math.sqrt(Math.pow(bottomRight.x - topRight.x, 2) + Math.pow(bottomRight.y - topRight.y, 2))
                        );

                        let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                            topLeft.x, topLeft.y,
                            topRight.x, topRight.y,
                            bottomRight.x, bottomRight.y,
                            bottomLeft.x, bottomLeft.y
                        ]);

                        let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                            0, 0,
                            width, 0,
                            width, height,
                            0, height
                        ]);

                        let M = cv.getPerspectiveTransform(srcTri, dstTri);
                        let dsize = new cv.Size(width, height);
                        let corrected = new cv.Mat();

                        cv.warpPerspective(src, corrected, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

                        const plotWidth = width / cols;
                        const plotHeight = height / rows;
                        const extractedPlots = [];

                        let plotNumber = 1;
                        for (let r = 0; r < rows; r++) {
                            for (let c = 0; c < cols; c++) {
                                const x = c * plotWidth;
                                const y = r * plotHeight;

                                let rect = new cv.Rect(x, y, plotWidth, plotHeight);
                                let plot = corrected.roi(rect);

                                const plotCanvas = document.createElement('canvas');
                                cv.imshow(plotCanvas, plot);

                                const ctx = plotCanvas.getContext('2d');
                                const imageData = ctx.getImageData(0, 0, plotCanvas.width, plotCanvas.height);
                                const greenCoverage = calculateGreenCoverage(imageData);

                                extractedPlots.push({
                                    id: `${imageQueue[currentImageIndex].id}-${plotNumber}`,
                                    plotNumber: plotNumber,
                                    row: r + 1,
                                    col: c + 1,
                                    image: plotCanvas.toDataURL(),
                                    greenCoverage: greenCoverage,
                                    sourceImage: imageMetadata.fileName,
                                    metadata: imageMetadata,
                                    imageQueueId: imageQueue[currentImageIndex].id
                                });

                                plot.delete();
                                plotNumber++;
                            }
                        }

                        // Update queue with completed plots
                        setImageQueue(prev => prev.map((item, idx) =>
                            idx === currentImageIndex
                                ? { ...item, status: 'completed', plots: extractedPlots }
                                : item
                        ));

                        // Add to all plots
                        setAllPlots(prev => [...prev, ...extractedPlots]);

                        setCommitted(true);

                        src.delete();
                        srcTri.delete();
                        dstTri.delete();
                        M.delete();
                        corrected.delete();

                    } catch (error) {
                        console.error('Error committing grid:', error);
                        alert('Error processing grid: ' + error.message);
                    }

                    setIsProcessing(false);
                }, 100);
            };

            const processImage = (img) => {
                if (!opencvReady) {
                    console.log('OpenCV not ready yet');
                    return;
                }

                setIsProcessing(true);

                setTimeout(() => {
                    try {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = img.width;
                        tempCanvas.height = img.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0);

                        let src = cv.imread(tempCanvas);
                        let gray = new cv.Mat();
                        let mask = new cv.Mat();

                        if (markerColor === 'white') {
                            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                            cv.threshold(gray, mask, 200, 255, cv.THRESH_BINARY);
                        } else {
                            let hsv = new cv.Mat();
                            cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
                            cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);

                            let lowThresh = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 100, 100, 0]);
                            let highThresh = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180, 255, 255, 255]);

                            cv.inRange(hsv, lowThresh, highThresh, mask);

                            hsv.delete();
                            lowThresh.delete();
                            highThresh.delete();
                        }

                        let kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5, 5));
                        cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernel);
                        cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);

                        let contours = new cv.MatVector();
                        let hierarchy = new cv.Mat();
                        cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                        const detectedCorners = [];

                        for (let i = 0; i < contours.size(); i++) {
                            let contour = contours.get(i);
                            let area = cv.contourArea(contour);

                            if (area >= minArea && area <= maxArea) {
                                let rect = cv.boundingRect(contour);
                                let centerX = rect.x + rect.width / 2;
                                let centerY = rect.y + rect.height / 2;

                                detectedCorners.push({
                                    x: centerX,
                                    y: centerY,
                                    area: area,
                                    rect: rect
                                });
                            }
                        }

                        setCorners(detectedCorners);

                        const dimensions = detectGridDimensions(detectedCorners);
                        setRows(dimensions.rows);
                        setCols(dimensions.cols);

                        initializeGridCorners(detectedCorners);

                        src.delete();
                        gray.delete();
                        mask.delete();
                        kernel.delete();
                        contours.delete();
                        hierarchy.delete();

                    } catch (error) {
                        console.error('Error processing image:', error);
                        alert('Error processing image: ' + error.message);
                    }

                    setIsProcessing(false);
                }, 300);
            };

            const handleReprocess = () => {
                if (originalImage) {
                    setCommitted(false);
                    processImage(originalImage);
                }
            };

            const processNextImage = () => {
                const nextIndex = currentImageIndex + 1;
                if (nextIndex < imageQueue.length) {
                    setCommitted(false);
                    loadImageFromQueue(nextIndex);
                }
            };

            const downloadAll = () => {
                allPlots.forEach((plot) => {
                    const link = document.createElement('a');
                    const fileName = plot.sourceImage.replace(/\.[^/.]+$/, '');
                    link.download = `${fileName}_plot-${plot.plotNumber}_coverage-${plot.greenCoverage.toFixed(1)}pct.png`;
                    link.href = plot.image;
                    link.click();
                });
            };

            const exportCSV = () => {
                let csv = 'Source Image,Plot Number,Row,Column,Green Coverage (%),GPS Latitude,GPS Longitude,Altitude,Date/Time,Camera Make,Camera Model\n';
                allPlots.forEach(plot => {
                    csv += `"${plot.sourceImage}",${plot.plotNumber},${plot.row},${plot.col},${plot.greenCoverage.toFixed(2)},`;
                    csv += `${plot.metadata.latitude || 'N/A'},${plot.metadata.longitude || 'N/A'},`;
                    csv += `${plot.metadata.altitude},"${plot.metadata.dateTime}",`;
                    csv += `"${plot.metadata.make}","${plot.metadata.model}"\n`;
                });

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'drone-trial-results-with-metadata.csv';
                link.click();
            };

            const avgCoverage = allPlots.length > 0
                ? allPlots.reduce((sum, p) => sum + p.greenCoverage, 0) / allPlots.length
                : 0;

            const completedImages = imageQueue.filter(i => i.status === 'completed').length;

            return (
                <div className="container">
                    <div className="header">
                        <h1>üöÅ Drone Image Processor - Turf Trial Grid Detector</h1>
                        <p>Multi-image support with EXIF metadata extraction</p>
                    </div>

                    <div className="content">
                        {!opencvReady && (
                            <div className="loading">
                                Loading OpenCV library... Please wait.
                            </div>
                        )}

                        <div
                            className={`upload-section ${isDragging ? 'drag-over' : ''}`}
                            onDrop={handleDrop}
                            onDragOver={handleDragOver}
                            onDragLeave={handleDragLeave}
                            onClick={() => fileInputRef.current?.click()}
                        >
                            <input
                                ref={fileInputRef}
                                type="file"
                                accept="image/jpeg,image/jpg,image/png"
                                multiple
                                onChange={(e) => handleFilesUpload(e.target.files)}
                                style={{ display: 'none' }}
                            />
                            <h2>üì∏ Drop Drone Images Here or Click to Upload</h2>
                            <p style={{ marginTop: '10px', color: '#666' }}>
                                Supports multiple JPEG and PNG images with EXIF metadata
                            </p>
                            <button className="upload-btn" style={{ marginTop: '20px' }}>
                                Select Images
                            </button>
                        </div>

                        {imageQueue.length > 0 && (
                            <div className="image-queue">
                                <h3>üìã Image Processing Queue ({completedImages}/{imageQueue.length} completed)</h3>
                                {imageQueue.map((item, idx) => (
                                    <div
                                        key={item.id}
                                        className={`queue-item ${item.status}`}
                                        onClick={() => item.status === 'completed' && loadImageFromQueue(idx)}
                                        style={{ cursor: item.status === 'completed' ? 'pointer' : 'default' }}
                                    >
                                        <div className="queue-info">
                                            <strong>{item.metadata.fileName}</strong>
                                            <div style={{ fontSize: '0.9em', color: '#666', marginTop: '5px' }}>
                                                {item.metadata.latitude && item.metadata.longitude && (
                                                    <span>GPS: {item.metadata.latitude}, {item.metadata.longitude} | </span>
                                                )}
                                                {item.metadata.dateTime} | {item.plots.length} plots extracted
                                            </div>
                                        </div>
                                        <div className={`queue-status status-${item.status}`}>
                                            {item.status === 'pending' && 'Pending'}
                                            {item.status === 'processing' && 'Processing...'}
                                            {item.status === 'completed' && `‚úì ${item.plots.length} plots`}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}

                        {imageMetadata && currentImageIndex !== null && (
                            <div className="metadata-section">
                                <h3>üìä Current Image Metadata</h3>
                                <div className="metadata-grid">
                                    <div className="metadata-item">
                                        <div className="metadata-label">File Name</div>
                                        <div className="metadata-value">{imageMetadata.fileName}</div>
                                    </div>
                                    <div className="metadata-item">
                                        <div className="metadata-label">File Size</div>
                                        <div className="metadata-value">{imageMetadata.fileSize}</div>
                                    </div>
                                    {imageMetadata.latitude && imageMetadata.longitude && (
                                        <>
                                            <div className="metadata-item">
                                                <div className="metadata-label">GPS Coordinates</div>
                                                <div className="metadata-value">
                                                    {imageMetadata.latitude}, {imageMetadata.longitude}
                                                </div>
                                            </div>
                                        </>
                                    )}
                                    {imageMetadata.altitude !== 'N/A' && (
                                        <div className="metadata-item">
                                            <div className="metadata-label">Altitude</div>
                                            <div className="metadata-value">{imageMetadata.altitude}</div>
                                        </div>
                                    )}
                                    <div className="metadata-item">
                                        <div className="metadata-label">Date/Time</div>
                                        <div className="metadata-value">{imageMetadata.dateTime}</div>
                                    </div>
                                    {imageMetadata.make !== 'N/A' && (
                                        <div className="metadata-item">
                                            <div className="metadata-label">Camera</div>
                                            <div className="metadata-value">{imageMetadata.make} {imageMetadata.model}</div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}

                        {image !== null && !committed && (
                            <>
                                {gridCorners.length === 4 && (
                                    <div className="info-box">
                                        <h4>üéØ Drag corner handles to adjust, then click Commit</h4>
                                        <p>Auto-detected: {rows} rows √ó {cols} columns - {corners.length} markers found</p>
                                    </div>
                                )}

                                <div className="controls">
                                    <div className="control-group">
                                        <label>Marker Color Type</label>
                                        <select
                                            value={markerColor}
                                            onChange={(e) => setMarkerColor(e.target.value)}
                                        >
                                            <option value="bright">Bright Colors (Default)</option>
                                            <option value="white">White/Light Markers</option>
                                        </select>
                                        <div className="value-display">Choose marker paint color</div>
                                    </div>

                                    <div className="control-group">
                                        <label>Grid Rows</label>
                                        <input
                                            type="number"
                                            value={rows}
                                            onChange={(e) => setRows(Number(e.target.value))}
                                            min="1"
                                            max="20"
                                        />
                                    </div>

                                    <div className="control-group">
                                        <label>Grid Columns</label>
                                        <input
                                            type="number"
                                            value={cols}
                                            onChange={(e) => setCols(Number(e.target.value))}
                                            min="1"
                                            max="20"
                                        />
                                    </div>

                                    <div className="control-group">
                                        <label>Green Sensitivity: {greenSensitivity}</label>
                                        <input
                                            type="range"
                                            min="10"
                                            max="60"
                                            value={greenSensitivity}
                                            onChange={(e) => setGreenSensitivity(Number(e.target.value))}
                                        />
                                        <div className="value-display">Adjust for grass colors</div>
                                    </div>
                                </div>

                                <div className="advanced-toggle">
                                    <button onClick={() => setShowAdvanced(!showAdvanced)}>
                                        {showAdvanced ? '‚ñº' : '‚ñ∂'} Advanced Marker Detection Settings
                                    </button>
                                </div>

                                <div className={`advanced-controls ${showAdvanced ? 'visible' : ''}`}>
                                    <div className="control-group">
                                        <label>Marker Min Area</label>
                                        <input
                                            type="number"
                                            value={minArea}
                                            onChange={(e) => setMinArea(Number(e.target.value))}
                                            min="1"
                                        />
                                        <div className="value-display">Minimum marker size (pixels¬≤)</div>
                                    </div>

                                    <div className="control-group">
                                        <label>Marker Max Area</label>
                                        <input
                                            type="number"
                                            value={maxArea}
                                            onChange={(e) => setMaxArea(Number(e.target.value))}
                                            min={minArea}
                                        />
                                        <div className="value-display">Maximum marker size (pixels¬≤)</div>
                                    </div>
                                </div>

                                <div style={{ marginBottom: '20px' }}>
                                    <button className="btn-secondary" onClick={handleReprocess}>
                                        üîÑ Reprocess
                                    </button>
                                    {gridCorners.length === 4 && (
                                        <button className="btn-success" onClick={commitGrid}>
                                            ‚úÖ Commit & Extract Plots
                                        </button>
                                    )}
                                </div>

                                {isProcessing && (
                                    <div className="loading">
                                        Processing... Please wait.
                                    </div>
                                )}

                                <div className="grid-preview">
                                    <h3>Adjustable Grid Preview (Drag Corner Handles)</h3>
                                    <canvas
                                        ref={gridCanvasRef}
                                        id="gridCanvas"
                                        onMouseDown={handleMouseDown}
                                        onMouseMove={handleMouseMove}
                                        onMouseUp={handleMouseUp}
                                        onMouseLeave={handleMouseUp}
                                    ></canvas>
                                </div>
                            </>
                        )}

                        {committed && (
                            <div style={{ marginBottom: '20px', textAlign: 'center' }}>
                                <div className="info-box">
                                    <h4>‚úÖ Image processed successfully!</h4>
                                    <p>Plots have been extracted and added to the collection</p>
                                </div>

                                {currentImageIndex < imageQueue.length - 1 && (
                                    <button className="btn-success" onClick={processNextImage}>
                                        ‚û°Ô∏è Process Next Image
                                    </button>
                                )}

                                <button className="btn-secondary" onClick={() => {
                                    setCommitted(false);
                                    setCurrentImageIndex(null);
                                    setImage(null);
                                    setOriginalImage(null);
                                }}>
                                    üèÅ Finish Processing
                                </button>
                            </div>
                        )}

                        {allPlots.length > 0 && currentImageIndex === null && (
                            <>
                                <div className="info-box">
                                    <h4>‚úÖ All Processing Complete - {allPlots.length} total plots extracted</h4>
                                    <p>Click any plot to view full-size with coverage details and metadata</p>
                                </div>

                                <div style={{ marginBottom: '20px' }}>
                                    <button className="btn-success" onClick={downloadAll}>
                                        üíæ Download All Plots
                                    </button>
                                    <button className="btn-success" onClick={exportCSV}>
                                        üìä Export CSV with Metadata
                                    </button>
                                    <button className="btn-secondary" onClick={() => {
                                        setImageQueue([]);
                                        setAllPlots([]);
                                    }}>
                                        üÜï Start New Session
                                    </button>
                                </div>

                                <div className="stats">
                                    <h3>üìä Complete Analysis Summary</h3>
                                    <div className="stat-item">
                                        <span><strong>Total Images Processed:</strong></span>
                                        <span>{imageQueue.filter(i => i.status === 'completed').length}</span>
                                    </div>
                                    <div className="stat-item">
                                        <span><strong>Total Plots Extracted:</strong></span>
                                        <span>{allPlots.length}</span>
                                    </div>
                                    <div className="stat-item">
                                        <span><strong>Average Green Coverage:</strong></span>
                                        <span style={{color: '#4CAF50', fontWeight: 'bold'}}>{avgCoverage.toFixed(1)}%</span>
                                    </div>
                                    <div className="stat-item">
                                        <span><strong>Highest Coverage:</strong></span>
                                        <span>{Math.max(...allPlots.map(p => p.greenCoverage)).toFixed(1)}%</span>
                                    </div>
                                    <div className="stat-item">
                                        <span><strong>Lowest Coverage:</strong></span>
                                        <span>{Math.min(...allPlots.map(p => p.greenCoverage)).toFixed(1)}%</span>
                                    </div>
                                </div>

                                <h3 style={{ marginTop: '30px', marginBottom: '15px' }}>All Extracted Plots with Metadata:</h3>
                                <div className="plots-grid">
                                    {allPlots.map(plot => (
                                        <div
                                            key={plot.id}
                                            className="plot-item"
                                            onClick={() => setSelectedPlot(plot)}
                                        >
                                            <img src={plot.image} alt={`Plot ${plot.plotNumber}`} />
                                            <div className="plot-label">
                                                <div className="plot-number">Plot {plot.plotNumber}</div>
                                                <div className="plot-metadata">{plot.sourceImage}</div>
                                                <div className="plot-coverage">
                                                    <span className="coverage-text">{plot.greenCoverage.toFixed(1)}%</span>
                                                    <div className="coverage-bar">
                                                        <div
                                                            className="coverage-fill"
                                                            style={{width: `${plot.greenCoverage}%`}}
                                                        ></div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </>
                        )}
                    </div>

                    <div className={`modal ${selectedPlot ? 'active' : ''}`} onClick={() => setSelectedPlot(null)}>
                        {selectedPlot && (
                            <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                                <span className="modal-close" onClick={() => setSelectedPlot(null)}>&times;</span>
                                <img src={selectedPlot.image} alt={`Plot ${selectedPlot.plotNumber}`} />
                                <div className="modal-info">
                                    <div className="modal-label">Plot {selectedPlot.plotNumber} - {selectedPlot.sourceImage}</div>
                                    <div className="modal-coverage">Green Coverage: {selectedPlot.greenCoverage.toFixed(1)}%</div>
                                    <div className="modal-metadata">
                                        {selectedPlot.metadata.latitude && selectedPlot.metadata.longitude && (
                                            <div>GPS: {selectedPlot.metadata.latitude}, {selectedPlot.metadata.longitude}</div>
                                        )}
                                        <div>{selectedPlot.metadata.dateTime} | {selectedPlot.metadata.make} {selectedPlot.metadata.model}</div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<TurfTrialDetector />, document.getElementById('root'));
    </script>
</body>
</html>
